#sources

##free

- <http://www.aboutdebian.com/network.htm>

##non free

[ste12]: <http://www.amazon.com/TCP-Illustrated-Volume-Addison-Wesley-Professional/dp/0321336313>

- [stevens - 2012 - tcp ip illustrate volume 1 2nd edition]

    Extremely clear and exemplified.

    Gives due emphasis to the key points.

    Great first book.

[dos06]: http://www.amazon.com/Understanding-TCP-IP-ebook/dp/B007TUYE0G/

- [dostalek - 2006 - Understanding tcp ip][dos06]

    Explains the most important internet protocol suite protocols deeply.

    Might not be the best first TCP IP book because it is a bit advanced,
    but it is a very good second one if you know the basics.

#osi vs ips

Models for network protocols.

IPS model has only 4 layers, OSI has 7.

Both seem to conatain more or less the same protocols, except that they are put into different layers.

IPS is simpler to remember where each protocol goes since it has less layers.

#ips

<http://en.wikipedia.org/wiki/Internet_protocol_suite>

##protocols in layers

Each layer contains many protocols, each of which helps the layer achieve its funcitons

Some of the most common protocols in each layer are and the function of the layers are:

- application: HTTP, HTTPS, FTP, DHPC and many more

    Whatever protocol any application uses.

    Many protocols are standardized by large organizations, and have a specific port
    reserved for them on each computer.

- transport: TCP and UDP are by far the most common

    The transport layer:

    - splits up the data for the application layer in more manageable chunks.

    - guarantees that each chunk arrived, and if not asks for it again.

- internet: IP is the most common

    Finds the path between any two computers even if they are not on the same network.

- link: ethernet, ARP

    Finds the path between two computers that are on the same network.

To get a feeling for what each layer does, learn some of the most popular protocols of each of those layers.

##layer data structure

Each layer adds a header to the layer below containing its information:

    | application data  |
    | transport data    | transport header |
    | internet data                        | internet header |
    | link data                                              | link data  |

- the transport data is the same as the application data.

- the internet data contains exactly:

    - the transport data
    - the transport header

- the link data conatins exactly:

    - the internet data
    - the internet header

##example: browser fetches page

A browser wants to make a typical HTTP request to a remove server to get a web page.

It knows the IP of that server.

The browser gives to the networking system

- the HTTP data
- the IP of the server
- the port on the server.

    HTTP is standardized by IANA to be accepted on port 80/tcp.

And then asks the networking system to:

- add TCP header data to the HTTP data generated by the browser to make a TCP package
- add an IP header to make an IP package.
- add an ethernet header to make an ethernet package.

Next the computer sends the ethernet header to its router, which is on the same network.

The router is able to receive that data because of the information contained in the ethernet header.

The router is now done with the ethernet header and throws it away.

The router puts the ethernet header...

TODO continue. Add diagrams.

#ip

Protocol that allows to:

- assign addresses to network interfaces (which have distinct hardware addresses),

- find path between one computer to another, possibly passing through many routers

##ip header

Learn what the IP header contains:

<http://en.wikipedia.org/wiki/IPv4_header#Header>

Fields by increasing interest / ease to understand ratio:

- version (4 bits)

    Indicates the protocol version.

    Value 4 for IPv4.

- internet header length (IHL) (4 bits)

    Length of the IP header only (no data) in 4 byte units.

- total length (2 bytes)

    Total length of header + body in bytes

    This must be transmitted as the length is variable.

- IPs of destination and origin (4 bytes each)

- time to live (TTL) (1 byte)

    Decresased whenever the packet passes through a router.

    If 0, router does not forward the package, because it has already traveled for too long,
    and signals this to the sender via an ICMP Time exceeded with Code = 0.

    This prevents lost packages from doing infinite turns on the network.

- header checksum (2 bytes)

- protocol (1 byte)

    Number that identifies the protocol contained in the IP data, for example TCP or UDP.

    In this way, the receiver knows how to interpret the data inside of the IP package.

    The numbers are assigned by IANA and can be found [here](http://en.wikipedia.org/wiki/List_of_IP_protocol_numbers).

- flags: 3 bits

    Used for IP fragmentation.

- fragment offset: (13 bits)

    Used for IP fragmentation.

- identification: (2 bytes)

    Used for IP fragmentation.

##ip fragmentation

If a router will forward this packet to anoter interface, it may be that the MTU
of the other inteface be smaller than the previous one, and the package cannot be transmitted hole.

In this case, IP provides a fragmentation mechanism to split up the package into smaller ones.

TCP always attempts to avoid IP fragmentation, so that if TCP is being used,
it is unlikely that fragmentation will happen. It is therefore easier to observe
IP fragmentation for UDP packets.

Reassembly of fragments is meant to happen only at the final destination.

The fields used from the IP header  are:

- flags (3 bits)

        | 0 | DF | MF |

    - 0: reserved, always set to 0

    - DF: don't fragment.

        If that is the case, the router first checks the `DF` flag.

        If `DF = 1`, routers should not fragment,
        and notify the source via an ICMP fragmentation not possible message.

        If `DF = 0`, fragmentation can occur, and tranmission continues.

    - `MF`: more fragments

        If 0, this is the last fragment.

        If 1, there are more fragments to come.

        A common technique is to send first the last segment,
        which allows the destination to know how large a buffer it will need in advance.

- fragment offset: (13 bits)

    How many 8 byte units of IP data have already been sent.

    The first fragment always has this field equal to 0.

    But if fragmentation occurs, the following fragments will contain how much IP data has been sent already.

- identification: (2 bytes)

    It is set by the sender with a different number for each IP datagram.

    If fragmentation will occurr, each fragment's IP header will get the same identification number
    so that they can be reassembled afterwards.

    Identification numbers can be the same across multiple source IPs,
    but for a single source IPs they are unique.

##ip address

An unique address that identifies a host, for example a separate workstation.

IPv4 addresses are 4 bytes long.

They are often noted byte by byte as:

    192.156.0.1

Each computer knows its IP address.

This can be set in two ways:

- statically and manually: admin enters those values for each computer.

    They never change.

- dynamically and automatically.

###ip classes

Each address has two parts: network part and host part.

####example: network and host parts

- 2 networks

- 3 bytes for the network part
- 1 router
- 3 computers on the same network

Things could look like:

    +---------------+  +---------------+  +---------------+
    | computer 1    |  | computer 2    |  | computer 3    |
    |---------------|  |---------------|  |---------------|
    | 192.156.0.2   |  | 192.156.0.3   |  | 192.156.0.4   |
    |+--------------+  |+--------------+  |+--------------+
    ||                 ||                 ||
    |+=================++=================++
    ||
    |+---------------+
    || 192.156.0.1   |
    ||---------------+
    || router        |
    ||---------------|
    || 192.157.0.1   |
    |+---------------+
    ||
    |+=================++=================++
    ||                 ||                 ||
    |+--------------+  |+--------------+  |+--------------+
    | computer 3    |  | computer 4    |  | computer 5    |
    |---------------|  |---------------|  |---------------|
    | 192.157.0.2   |  | 192.157.0.3   |  | 192.157.0.4   |
    +---------------+  +---------------+  +---------------+


How many bytes are the network, and how many bytes are the host was determined
only by the class of the IP in the past.

Each computer must know how many bytes are network and how many are host.

In the past, there were 5 IP ranges:

- A: starts with 0
- B: starts with 10
- C: starts with 110
- D: starts with 1110
- E: all others

IPs on classes A, B and C were reseverved for internal use.

If your address is in those ranges,
the routers proxy server knows it is an internal one you are asking about

most common home range is the Class C:

192.168.0.1 through 192.168.255.254
subnet mask 255.255.255.0

###external vs internal ip

If you use a router, all computers behind the router have a single external ip seen
you have an external ip seen on the web and an internal ip seen on the private
local network (lan).

Get external ip:

    curl http://ipecho.net/plain
    curl ifconfig.me

Get internal adresses for current computer:

    ifconfig | grep -B1 "inet addr" | awk '{ if ( $1 == "inet" ) { print $2 } else if ( $2 == "Link" ) { printf "%s:" ,$1 } }' | awk -F: '{ print $1 ": " $3 }'

Different ones for wireless and for wired connections

Computers in the network only talk to the router.

The server on the router is called **proxy server**.

###subnet mask

####get mask for an interface:

    ifconfig wlan0 | sed -nr 's/.*Mask:([^ ]*)/\1/p'

internal ips have two parts: network and computer

the length of the network part may vary between networks

the length is given by the **subnet mask**, ex:

255.255.255.0
1111.1111.1111.0000

means that 12 first bits are network

255.255.0.0

means that 8 first bits are network

all computers in the same network must have the same subnet mask and the same
network part, but different computer parts.

each network (formally **network segment**) is run by a single router #TODO confirm

###special adresses

####zero host address

<http://serverfault.com/questions/135267/what-is-the-network-address-x-x-x-0-used-for>

If the entire host part is zero, then the address is used to refer to the network itself.

It is used when several networks, one one a different router must speak to each other.

###default gateway

0.0.0.0 network address in the routing table.

If no network matches request, sends to this network.

Address you get automatically redirected to by reuter if the address you gave cannot be found on the local network.

Find default gateway:

    route -n

or for programatic usage:

    route -n | awk '{ if( $1 ~ "0.0.0.0" ) print $2 }'

###broadcast address

The host address is entirely composed of 1s.

The broadcast address means talking to all computers on a given network at once
instead of a single computer

####examples

#####class c network

- network part: 192.168.3

broadcast is: 192.168.3.255

- network part: 192.168.234

broadcast is: 192.168.3.255

#####class a network

- network part: 10

broadcast is: 10.255.255.255

###.1 addresses

.1 is not special, but in home networks is often already taken by the router's inner interface

this is why your addresses may start at .2

##NIC

Network Interface Cards

Hardware that does netowrk communication.

Come mostly built-in the motherboard today.

Each router has at least 2 NICs: one external and one internal.

###get all interface names

    ifconfig | perl -ne '/^(\S+)/ && print $1 . "\n"'

##MAC

aka:

- physical address
- hardware address
- media access control address
- BIA: burnt in address

unchangeable address of each NIC

unique across and within vendors

6 bytes: first 3 identify vendor, last 3 product

colon separated notation. Ex: `0C:21:B8:47:5F:96`

aka:

- physical address
- hardware address
- media access control address
- BIA: burnt in address

get MAC addresses of my computer:

    ifconfig

or for programmatic usage:

    ifconfig | sed -nr 's/([^ ]*) .*HWaddr (.*)/\1 \2/p'

get MAC addresses of computers i have already talked to in the lan:

    timeout 3 ping 192.168.1.3
    arp -a | sed -nr 's/([^ ]*) .*at (.*)/\1 \2/p'

#tcp vs udp

Different protocols

TCP guarantees that information packages arrive, UDP does not.

For that, tcp has to maintain a connection,
while udp simply sends the packages and hopes for the bes

For this reason, udp has less overhead, but is only used when the transaction
will limit itself to a single request/answer.

Some protocols include both a TCP and a UDP version, which may vary slightly
while others only have either a TCP or an UDP version
see <http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers> for a listcounting acknowledge packages

##icmp

Internet control message protocol.

Protocol that is part of the IP protocol.

Contains several types of information for routers about the IP traffic.

Lives in the internet layer, but is encapsulated inside an IP datagram just like TCP and UDP:

    | ICMP data |
    | IP data   | IP header |

Its number on the IP protocol field is 1, so you may guess that this is a very important protocol.

Structure of the ICMP header

    - Type 1B
    - Code 1B
    - Checksum 2B
    - Variable part 4B

ICMP can also constain an optional extra data section after the vairable part.

Examples of what ICMP can do:

- ECHO requests.

    The server responds with another echo request with the same data.

    Used to testing the netowork.

    Used by the ping utility.

- destination unreachable

    Datagram cannot be tranmited futher by a router.

    TODO when does this happens? This is not the TTL = 0 since that is covered by Time Exceeded

- source quench

    Router tells source to lower sending speed because the network is too overloaded.

- redirect

    Router tells source to not make that request again, since there is an obvious better choice
    of router to make the request to.

    Typically happens on a LAN with 2 routers, if a host sends a request to a bad router.

- router discovery

    Source asks for any routers on the LAN to identify themselves.

- time exceeded.

    - if `code = 0`: TTL reached 0.

        Router notifies source of that via ICMP.

        Used by `traceroute`.

    - if `code = 1`: reassembly time exceeded.

        IP headers can be fragmented.

        If the first part reaches, but the second takes too long, the reciever
        discards the first to make room for other requests, and notifies the source like this.

- packet too big (BTP)

    Sent by router to source if it receives a packet that is larger than the MTU
    and the IP header has `DF = 1`.

##igmp

Internet group message protocol

Similar to ICMP in some senses:

- wrapped inside IP
- IP control purposes

however IGMP is used to control multicasts only.

IP protocol number: 2.

#ping

CLI utility that sends ICMP echo requests to a server that accepts them.

It measures the time it takes for the answer to come back, which is a measure of connectivity
between the two computers.

It is often used in online games.

The default IANA port for ping requests is port 7/tcp or 7/udp.

Send an echo every second to monitor connectivity:

    ping www.google.com

#traceroute

Linux utility that shows each step an IP package takes to reach a destination.

Operation is simple: the program sends the request with TTL = 1, TTL = 2, TTL = 3, and so on,
and gets the address at which it stopped via ICMP time exceeded router responses.

Exapmle:

    traceroute www.google.com

#tcp

Learn the tcp header:

<http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure>

Interesting notes:

- tcp determines the ports

#tcpdump

CLI utility that allows to visualize tcp packets sent and received.

Good intro tutorial: <http://danielmiessler.com/study/tcpdump/>

Also consider wireshark, whose output is generally easier to interpret
(but unfortunately is a X GUI instead of CLI).

Most useful options:

- `-X` show ascii and hex side by side:
- `-n` don't resolve hostnames, show numeric IPs
- `-S` don't resolve hostnames, show numeric IPs
- `-vvv` maximum verbosity level

    Interprets standard data types and prints them, making output easier to understand.

Example:

    sudo tcpdump -SXn

#wireshark

Set of utilities that that capture TCP IP packages similarly to tcpdump.

Analyses packages if possible, and presents them on a human readable way.
For this reason this is an amazing tool to really understand everything
that goes on your computer's network interfaces.

Open source and cross platform (Linux and Windows).

#netrc

`$HOME/.netrc` is a config file that automates net logins
(TODO: which type exactly of login?)

ex:

    machine code.google.com login <login> password <pass>

#host

A host is anything able to send and receive packages over a network:
this includes workstations (computers) and routers.

Can be specified by either

- an IP
- a string that will be resolved by a dns server to an IP

##host user pair

A user may access a (system) computer from another computer using for example ssh.

To do so, he must be registered in the target computer.

This is why user/host pairs are common:
the host pair says from which computer user is trying to access his account.

#hostname

An alias for your desired IP on a local network.

Must be converted into an IP via DNS.

#dhcp

Dynamic host configuration protocol.

<http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol>

Application layer protocol that automatically assigns configurations to the hosts on a network,
such as their IP.

Default IANA ports: udp 67 and 68 (same as its less advanced and less common predecessor `BOOTP`)

When a computer enters a network and it does not know its own IP.

It must first send a DHCP request to be assigned an IP.

#hosts file

Located at:

    /etc/hosts

Tells your computer where to redirect the given names.

Takes precedence over DNS.

Big downside: you have to have one of this file on every PC.

therfore, use a dns server instead

    cat /etc/hosts

Redirect wikipiedia to localhost:

    echo "127.0.0.1 www.wikipedia.org" | sudo -a /etc/hosts

Now:

    firefox www.wikipedia.org &

will go to localhost, and you will see your apache page if you are running apache.

Undo that:

    sudo sed -i "$ d" /etc/hosts

##windows

The file is:

    C:\Windows\System32\Drivers\Etc\hosts

#dns

Domain name system.

Part of the application layer of the IPS.

Standard IANA port: 53/udp

Protocol that convert strings into ips, for example:

    http://www.google.com -> 173.194.34.34

Before before using an address such as `www.google.com`, any program such as a browser
must first resolve the hostname `www.google.com` into an IP.
by asking that from a server.

Linux systems usually offer `man resolver` C library interface, which any program can use to resolve
DNS names. The resolver library may cache results across applications that have already been resolved.

###dns on wan

On the internet, hostnames are resolved to IPs by DNS servers.

You must pay to reserve hostnames so they can be resolved to the IP of your choice.

TODO how to DNS servers find out all the hostnames in the world?

##dns on lan

DNS can also be done for local networks:

    computer2 -> 192.168.0.3

in which case the DNS server normally resides on the router.

Clients computers on the network are informed that it is a DNS server via DHCP.

On your lan, people can use the host name to communicate between computers

For example, John is running an apache server on the usual port 80. He has hostname `john`.

Mary is on the same netowk. Therefore, she can refer to john simply as john. For example:

    ping john
    firefox john

TODO if many people set up the same hostname, then what?

##host utility

Get ip for a given hostname:

    host www.google.com

Sample output:

    173.194.78.105

##resolv.conf file

Located at:

    /etc/resolv.conf

Lists DNS servers (they resolve hostnames into IPs ).

This file may be automatically generated by utilities.

Weirdly, mine contains:

    nameserver 127.0.1.1

which is localhost. TODO understand why? It seems that the DHPC deamon set that.

The actual nameserver can be found with the `dig | grep SERVER` command.

##hostname utility

Print currently desired hostname:

    echo $HOSTNAME
    hostname

In the default bash `PS1` line for ubuntu and many systems you see:
`ciro@ciro-Thinkpad-T430`, then the hostname is `ciro-Thinkpad-T430`.

Change hostname for cur session:

    h=
    sudo hostname "$h"

prompt `PS1` is not changed immediatelly.

##change hostname permanently

    h=
    echo "$h" | sudo tee /etc/hostname

###windows

host is reffered to as "computer name". good name choice.

    wmic computersystem where name="%COMPUTERNAME%" call rename name="NEW-NAME"

##reverse dns

Protocol that transforms an IP into a hostname.

Not always supported on all DNS servers.

#port

Once you have determined a host (computer),
you still have to talk to one of the specific programs running on that computer.

Each program listens on an specific port which is set by convention.

Ports from 1 - 1000 all have reserved or standardized functions by an organization called IANA:
<http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers>

There are 2 ports number 10: 10/tcp and 10/udp, each for a different protocol.

On POSIX systems, ports are typically implemented via sockets.

##read and write to a port from the command line

You can write to a port in many ways using the command line.

#router

Routers send packages from one place to another.

Most routers will have at least two network interfaces, one on each network.

##configure you router

If you wanto to play around with routers, you should get your hands dirty and do some router configuring.

Routers are generally configured through a browser.

First you must make a wired connection to the router.

You must enter the IP address of your router. This is fixed and supplied by the router manufacturer.

You must then enter a username and a password. A default will be supplied by the manufacturer,
such as `admin` `admin`, or `admin` `password`. This can be changed once you logged in.

##routing table

Great lan routing example: <http://en.wikipedia.org/wiki/Default_gateway>

Routing tables say: if the request should go to a given network,
send it to a given interface.

0.0.0.0 is the default if no other is found

routers have two interfaes each: inside and outside

#ifconfig

network InterFace configuration

includes stuff like IPs, subnet masks, MAC, etc

good source: <http://www.thegeekstuff.com/2009/03/ifconfig-7-examples-to-configure-network-interface/>

    ifconfig

sample interfaces on a modern laptop:

- eth0  wired network 0
- wlan0 wifi card 0
- lo    loopback (local host)

get local ips (behind router)

    ifconfig | grep -B1 "inet addr" | awk '{ if ( $1 == "inet" ) { print $2 } else if ( $2 == "Link" ) { printf "%s:" ,$1 } }' | awk -F: '{ print $1 ": " $3 }'

remember, wlan0 and eth0 are two different interfaces!

#iwconfig

wireless network configuration

#arp

Adress resolution protocol.

Only used when the sender detects that the searched IP is on the same network as itself.

In that case, it can simply get the destination MAC address and send the packages over the LAN directly
to the destination without passing through the router.

ARP is a protocol that does just that: it finds the MAC address from an IP on a LAN.

##arp table

Cache that caches previously resolved IP to MAC addresses so that ARP requests don't need to be made every time.

Also known as: ARP cache, MAC cache.

##arp utility

CLI utility that shows the ARP table.

To see a computer on the table, remember that you first must have tried to contact it somehow,
so first ping that computer:

    timeout 3 ping 192.168.1.3; arp -a

#route

view kernel routing table

    route

numeric instead of names

    route -n

#whois

check info about ip (country and ISP included)

    whois 201.81.160.156

    whois `curl ifconfig.me`

#ifup

TODO

##/etc/network/interfaces

###manual

    man interfaces

###set static ip

on a home network that you control,
it is better to use intuitive hostnames
and let the addresses be dynamic,
unless some app really requires you
to enter ips.
see hostname for how.

    sudo vim /etc/network/interfaces

    auto lo wlan0 eth0

    iface wlan0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    broadcast 192.168.1.255
    gateway 192.168.1.1

- auto if1 if2

    automatically create interfaces if1 and if2 on `ifup -a`

- iface if1

    from now on, define properties of if1

#mtu

<http://en.wikipedia.org/wiki/Maximum_transmission_unit>

Maximum transmission unit.

Maximum packet size that can be tranmitted over a physical link.

Varies across different link technologies.

#nmap

show open ports, state and service name associated to the port

TCP services:

    nmap google.com
    nmap localhost

you are gonna get at least 80 on google for their http server
and on localhost too if you are running an http server such as apache.

sample output excerpt:

    PORT     STATE SERVICE
    80/tcp   open  http

TODO understand STATE and where SERVICE comes from

view UDP ports:

    sudo nmap -sU localhost

#netstat

Shows lots of POSIX sockets info.

Get list pid and program name of programs using ports:

Shows both tcp/udp internet connections and UNIX domain sockets

In short: Internet connections are done via sockets whose address is given by
an ip and a port number, and can communicate across computers

UNIX domain sockets are only for local communication.
They are put into the filesystem and identified by a path on the filesystem

When a program uses a socket, it binds to it, and other programs cannot use it.

Most useful options:

- `-n`

    Don't resolve IPs into hostnames.

    Gretly speeds up the output generation.

- `-a`

    Show both listening and not listening ports.

- `-p`

    Show program name and pid.

- `-t`

    Show only tcp

- `-u`

    Show only udp

- `-x`

    Show only UNIX sockets

- `i`

    Show information on interfaces.

- `r`

    Show kernel routing table.

- `-s`

    Show statistics on serveral protocols.

Sample output for internet section:

    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp        0      0 localhost:32842         localhost:48553         ESTABLISHED 3497/GoogleTalkPlug

#telnet

protocol for comunicating between servers and name of command line tool that uses it

no encryption, therefore *DONT'T SEND PASSWORDS ON UNTRUSTED NETWORK WITH THIS*!!

always use ssh which is encrypted for anything even remotelly Pserious

the other computer must be running a telnet server

fun MUD games!

make http requests by hand for learning purposes:

    telnet google.com 80

type:

    GET / HTTP/1.0 <enter><enter>

you've made a get request by hand!

TODO won't work, why? how to programatically write characters on a request?

    echo $'GET / HTTP/1.0\n\n' | telnet www.google.com 80

also consider:

- nc
- socat

#nc

aka netcat

open, listen, send and receive tcp/udp packages and sockets

make an http get request manually to google.com:

    echo 'GET / HTTP/1.0' | nc google.com 80

if you have apache working on your computer, you can also do it on localhost to test:

    echo 'GET / HTTP/1.0' | nc localhost 80

in both cases you should get the HTTP re

`-u`: udp requests

#ssh

Protocol like telnet, but encrypted

Predominant implementation: OpenSSH, open source.

For ssh to work you will need:

- a ssh server running on a machine.
- a ssh client running on another machine.

It is possible to do tests using `localhost` on a single machine.

Per user configurations for both the server and the client are contained under `~/.ssh`

##server

Known as `sshd`, which standas for ssh deamon.

Must be installed and running on a machine for users from other computers to log into that machine.

The server part of ssh is called sshd.

Configuration:

    sudo cp  /etc/ssh/sshd_config{,.bak}
    sudo vim /etc/ssh/sshd_config

For the server to work, thw following configuration is minimal:

    Host *                  #config for all hosts
    Port 22                 #open port 22
    AllowUsers user1 user2  #allow the given users

The server is often started as part of the initrd system.

Therefore, to get it running you will probably use:

    sudo service ssh start

and to stop it:

    sudo service ssh stop

and to check its status:

    sudo service ssh status

##client

The client connects to a server to give shell access on the server.

Make sure that the configuration file is correct:

    sudo cp  /etc/ssh/ssh_config{,.bak}
    sudo vim /etc/ssh/ssh_config

Get the version of your ssh client:

    ssh -V

Connect to hostname with your current username:

    ssh $host

For local tests, use localhost and the current user:

    host=localhost
    user=`id -un`

For this to work you need:

- your host (computer) is allowed. See ssh server.
- your user is allowed. See ssh server.
- your user exists as a regular user in the *server* computer. See useradd.

There are two main methods of connection:

- using an authorized public RSA id, which does not require a password
    (unless your password is locally encrypted by a password, which is recommended).

    This method is used if the key is allowed.

- using the same password as the user on the server has.

    This method is only used if there is not authorized key on the local machine.

Connect to hostname with the given username:

    ssh $user@$host

or:

    ssh -l $user $host

Choose port:

    p=22
    ssh -p $p $h

The default is 22 specified by IANA, so don't change it if you can avoid it.

It is *not* possible to set ports via the common URL syntax: `ssh host:22`.

###authorized_keys

For this method to work, the server must have your public RSA key authorized.

The default location for authorized keys is `~/.ssh/authorized_keys`.
This location can be configured on the server.

This means that to login as user `u`, the file `/home/u/.ssh/authorized_keys`
must contain your public key. With that you will only be able to login into
the account of user `u`.

This file contains one public key per line, which may be preceeded by some options,
typically to restrict what the session can do, for example:

    from="ok.com",no-port-forwarding,no-X11-forwarding,
    no-agent-forwarding,no-pty ssh-rsa <key> <comment>

Non opvious options above include:

- only connections coming from `ok.com` will be accepted
- 

Options are documented with the server at `man sshd` since they are only used by the server.

*Never* put your private key there!

Next, your client will only connect to a server if its key is in known hosts.
Security is useless if someone is impersonating the message reciever.
If the server's public identity is not in the known hosts file, ssh will ask
is you want to add it.

##ssh-keygen

Generates public and private key pairs for use with ssh.

Generate an RSA public private pair:

    ssh-keygen -t rsa -C "you@email.com"

By default the keys are put under `~/.ssh` with names `id_rsa` for the private and `id_rsa.pub`
and have length 1024 bits.

*Do* use a passphrase, otherwise anyone that gets his hand on your `id_rsa` file owns your identity.

*Never* share your private key! It is like a password that allows you to connect to servers.

There can be only one key per file.

The formats are for the public key:

    ssh-<type> <public-key> <comment>

For the private key:

    -----BEGIN RSA PRIVATE KEY-----
    <key>
    -----END RSA PRIVATE KEY-----

The actual data format a bit more involved. Discussion [here](http://stackoverflow.com/questions/12749858/rsa-public-key-format).
Basically the data is base64 encoded, and it also contains some necessary algorithm metadata.

Often used to determine if a key is present or not is the key's fingerprint, which are just hashes of the keys.

Fingerprints are often displayed on the following format:

    43:51:43:a1:b5:fc:8b:b7:0a:3a:a9:b1:0f:66:73:a8

with the colons added for only readability.

You can get the fingerprint or all the fingerprints present on a file via:

    ssh-keygen -lf ~/.ssh/id_rsa
    ssh-keygen -lf ~/.ssh/id_rsa.pub
    ssh-keygen -lf ~/.ssh/known_hosts

##usage

Once you log in, it is as if you had a shell on the given ssh server computer!

You cannot copy files between computer with ssh directly,
but you can use scp or sftp to do it

Note how you appear on the who list:

    who

To close your connection:

    logout

or enter `CTRL-D`.

###gui applications

It is possible to run X applications remotely,
but it may be that the default configurations don't allow you to do that.

To allow X, make sure that the line:

    ForwardX11 yes

is present and uncommented on both client and server configuration files.

Now you can do:

    firefox

and it should work.

If you forget to let `ForwardX11 yes`, you would get errors like:

    Error: can't open display
    Error: display not specified

#scp

cp via ssh.

Get a file:

    p= #path to local file
    d= #destination directory
    u=
    h=
    scp $u@$h:$p $d

Send a file to server:

    scp $p $u@$h:$d

Send recursively for directories:

    scp -r $u@$h:$p

Send multiple files/dirs:

    scp -r $u@$h:"$p1" $u@$h:"$p2"

#sftp

ftp with ssh encryption

#samba

open source linux implementation of the SMB/CIFS networking protocol
used by default on windows

it allows for file, printer and driver sharing on a network

best option for cross platform file transfers

#browser

##firefox

comes by default

search with default engine:
    firefox -search asdf

starts with disabled extensions in case they are causing a crash:
    firefox -safe-mode

##w3m

ncurses web broser!

might save you if x goes down

#files

TODO

##/etc/protocols

##/etc/services

##/etc/udev/rules.d/70-persistent-net.rules

#deployment

##zymic

free php

did not work well with wordpress, probably some php restrictions.

##000

worked for wordpress

##openshift

open source

operated as service by redhad

ssh access

languages: python, java, ruby

lots of startups including wordpress

number of apps quite limited: 3 per account

console local client:

    sudo gem install rhc

start app (apps are stopped by default):

    sudo gem install rhc

error logs:

#vpn

TODO get working

Control another computer with you computer.

Unless the other computer says who you are,
it is impossible to tell that you are not the other computer

Several protocols exist.

    sudo aptitude install network-manager-openvpn network-manager-openvpn-gnome

Servers:

- <http://www.vpnbook.com/#pricing>

##ssl

Predecessor of TSL.

##tls

Transport Layer Security.

Encryption methods that encrypt the transport layer traffic.
