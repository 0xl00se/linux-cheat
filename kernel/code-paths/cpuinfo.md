# cpuinfo

This is mostly a superset of: <http://unix.stackexchange.com/questions/43539/what-do-the-flags-in-proc-cpuinfo-mean/219674#219674>

Here is the fuller code path:

-   `fs/proc/cpuinfo.c`: implements the proc entry.

    `__init proc_cpuinfo_init` is the initializer called at startup.

    `proc_cpuinfo_operations` is used there, The only `cpuinfo` specific operation is `open`, which uses `cpuinfo_open`, which uses `cpuinfo_op`.

-   `arch/x86/kernel/cpu/proc.c` defines `cpuinfo_op`

    Upon a quick inspection, `.show = show_cpuinfo` is the more interesting callback, and outputs the `"flags` string which we are looking for.

        seq_puts(m, "flags\t\t:");
        for (i = 0; i < 32*NCAPINTS; i++)
            if (cpu_has(c, i) && x86_cap_flags[i] != NULL)
                seq_printf(m, " %s", x86_cap_flags[i]);

    The for loop prints `x86_cap_flags` strings.

-   `x86_cap_flags` are generated by `arch/x86/kernel/cpu/mkcapflags.h` directly from `arch/x86/include/asm/cpufeature.h` by "parsing" it with `sed`...

    The output goes to `arch/x86/kernel/cpu/capflags.c` of the build directory, and resulting array looks like:

        const char * const x86_cap_flags[NCAPINTS*32] = {
            [X86_FEATURE_FPU]        = "fpu",
            [X86_FEATURE_VME]        = "vme",

    so for example `X86_FEATURE_FPU` corresponds to the string `"fpu"` and so on.

-   `cpu_has` is defined at `arch/x86/include/asm/cpufeature.h`:

        #define cpu_has(c, bit)							\
            (__builtin_constant_p(bit) && REQUIRED_MASK_BIT_SET(bit) ? 1 :	\
            test_cpu_cap(c, bit))

    This breaks up into two cases:

    -   `REQUIRED_MASK_BIT_SET`: the flag is required for the kernel to run. It comes down to data in `required-features.h`, which comments:

            Define minimum CPUID feature set for kernel These bits are checked
            really early to actually display a visible error message before the
            kernel dies.  Make sure to assign features to the proper mask!

        So those have already been checked before, and are taken for granted.

    -   `test_cpu_cap`: this uses up `CPUID` data from the `struct cpuinfo_x86 boot_cpu_data` global

-   `struct cpuinfo_x86 boot_cpu_data` is defined at `x86/kernel/setup.c`

    It is further initialized at `x86/kernel/cpu/common.c:identify_boot_cpu` which is `__init` and thus run at startup.

    The chain `identify_cpu` -> `generic_identify` -> `get_cpu_cap` -> `x86/include/asm/processor.h:cpuid` -> ... -> `asm volatile("cpuid"`

    `get_cpu_cap` maps many parts of CPU id output to the `x86_capability` array, e.g.:

        cpuid(0x00000001, &tfms, &ebx, &excap, &capability);
		c->x86_capability[0] = capability;
		c->x86_capability[4] = excap;

    So for e.g. `x86_capability[0]` contains `edx` of `CUPID` 1, and `x86_capability[4]` contains `ecx`.

    The full list is:

        x86_capability | eax[31] | eax[0..15] | ecx | output register | file that sets it | notes
         0 0  1 0 edx common.c
         1 1  1   edx common.c
         2 cpuid_edx(0x80860001) transmeta.c | https://en.wikipedia.org/wiki/Transmeta acquired by Novafora https://www.crunchbase.com/organization/novafora
         4 0  1 0 ecx common.c
         5 cpuid_edx(0xC0000001) centaur.c | Centaur and Cyrix were bought by VIA: https://en.wikipedia.org/wiki/VIA_Technologies
         6 1  1   ecx common.c
	     9 0  7 0 ebx common.c
	    10 0 10 1 eax common.c
	    11 0 15 0 edx common.c
	    12 0 15 1 edx common.c

    - 3 set_cpu_cap
    - 7 scattered.c
    - 8 scattered.c + set_cpu_cap

        #define set_cpu_cap(c, bit)	set_bit(bit, (unsigned long *)((c)->x86_capability))
